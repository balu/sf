\nwfilename{sf.nw}\nwbegindocs{1}The \unix{sf} program is an ncurses-based file selector. A command% ===> this file was generated automatically by noweave --- better not edit it
line of the form \unix{sf /path/to/dir} shows the list of files in the
directory \unix{dir} and allows the user to select files from
them. Upon exit, the \unix{sf} utility writes the full path of all
selected files onto the standard output, one file per line.  We use an
ncurses based UI since the primary motivation for this program is to
enable the user to quickly select some files to be processed by other
command line utilities. The program also supports accepting a list of
files from the standard input using \unix{-} as the directory
argument.

The central data structure manipulated by the \unix{sf} utility is the
\emph{file list}. Upon startup, the file list contains all files in
the directory \unix{dir} or the list of files specified in the
standard input. All files are marked unselected upon startup. There
are user commands to modify the selection and the file list. The
program also maintains a \emph{current file pointer} to help the user
move around in the file list.

The following list describes the basic set of user commands.

\begin{description}

\item [\unix{<num=1>j}] Move the current file \unix{num} positions
down.

\item [\unix{<num=1>k}] Move the current file \unix{num} positions up.

\item [\unix{m}] Mark the current position. Note that this commands
marks a position and not a file. This means that if you store a mark
and later change the ordering of files, then the next command that
uses the stored mark does not have any information about the file that
used to be in the marked position.

\item [\unix{<num=0>;}] Set the current file to \unix{num} or the
marked file.

\item [\unix{<sortfield>a}] Sort the file list in non-increasing order
of sort field. Supported values of \unix{sortfield} are \unix{'n}
(Name), \unix{'m} (Last modified time), \unix{'a} (Last accessed
time), \unix{'s} (size), \unix{'g} (glob matched), \unix{'u} (user
selected), and \unix{'t} (file type).

\item [\unix{r}] Reverse the order of files.

\item [\unix{<glob>g}] Go to the first file matching \unix{<glob>}.

\item [\unix{n}] Go to the next file matching the last entered glob
command.

\item [\unix{N}] Go to the previos file matching the last entered glob
command.

\item [\unix{q}] Quit and write paths of all selected files to
standard output.

\item [\unix{Q}] Quit without writing paths of all selected files to
standard output.

\item [\unix{s}] Select the current file or if there is an active
mark, select all files between the mark and the current file.

\item [\unix{S}] Deselect as in \unix{s} command.

\item [\unix{t}] Toggle selection status as in \unix{s} command.
\end{description}

The command processor maintains a data stack. The data items entered
by the user are pushed onto the stack to be used by subsequent
commands. Each data item is a string, or a number, or a character, or
a mark. To push a data item to the stack, simply enter the data
item. A mark is pushed to the stack by the \unix{m} command. The
commands always use the top data item. For example, if the user enters
\unix{'g "*sf*" 5 j g a}, then the following sequence of operations
are performed.

\begin{itemize}

\item Move the current file 5 positions down.

\item Glob search with the glob pattern \unix{*sf*} and jump to the
first matching file.

\item Sort the files such that the glob matched files appear on the
top.

\end{itemize}

The following are the additional user commands implemented that
provide some advanced functions.

\begin{description}

\item [\unix{p}] Prints the top element of the data stack.

\item [\unix{P}] Pops the top element of the data stack.

\end{description}

\unix{sf} also supports multiple output formats through the option
\unix{-o} or the equivalent long form \unix{--output}. The possible
arguments to this option are:

\begin{description}

\item [\unix{n}] One file per-line. Assumes that there are no newlines
in filenames. This is the default.

\item [\unix{q}] Double-quoted, separated by spaces.

\item [\unix{z}] Files are separated by null-bytes. This can be useful
to interface with \unix{xargs}.

\end{description}

\newpage

The {\Tt{}FileImpl\nwendquote} structure is the representation of a file presented
to the user. The standard library provided {\Tt{}DirEntry\nwendquote} is a structure
that is equivalent to this except that calling accessor methods such
as {\Tt{}size\nwendquote} returns the current size. However, since our application
is supposed to be a short running one, we will just take a snapshot of
all relevant file attributes and store them throughout the lifetime of
the program.

\nwenddocs{}\nwbegincode{2}\moddef{File implementation}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
struct FileImpl
\{
  private:
  const string path;
  const string name;
  const string type;
  const ulong  size;
  const long   atime;
  const long   mtime;

  public:
  // XXX: May throw Exception.
  this(in string p)
  \{
    this(DirEntry(p));
  \}

  this(DirEntry d)
  \{
    path = d.name;
    name = baseName(path);
    if (d.isDir)
      type = "Directory";
    else if (d.isSymlink)
      type = "Symlink";
    else if (!extension(name))
      type = "Unknown";
    else
      type = extension(name);
    size = d.size;
    atime = d.timeLastAccessed.toUnixTime;
    mtime = d.timeLastModified.toUnixTime;
  \}
\}

\nwendcode{}\nwbegindocs{3}The {\Tt{}FileList\nwendquote} structure represents the list of files presented to
the user. Each file read by the program gets a unique {\Tt{}FileIndex\nwendquote}
that will remain fixed throughout the program. The {\Tt{}ViewIndex\nwendquote} of a
file represents the position of the file in the list presented to the
user. The {\Tt{}ViewIndex\nwendquote} of a file can be changed by the user, for
example, by sorting the file list.

\nwenddocs{}\nwbegincode{4}\moddef{Indices definition}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
alias FileIndex = Index!("F");
alias ViewIndex = Index!("V");
alias GlobIndex = Index!("G");

\nwendcode{}\nwbegindocs{5}The arrays {\Tt{}file{\_}\nwendquote} and {\Tt{}view{\_}\nwendquote} stores how the files are
permuted. The element {\Tt{}file{\_}[i]\nwendquote} is the file index of the
$i^\text{th}$ file in the user's view of the file list. Conversely,
the element {\Tt{}view{\_}[i]\nwendquote} is the position, on screen, of the file with
file index $i$ . Therefore, the file index is an iterator that is
never invalidated. The array {\Tt{}glob{\_}\nwendquote} stores the list of glob matched
files. The array {\Tt{}selected{\_}\nwendquote} is a bitmap of selected files. This
inconsistency between {\Tt{}glob{\_}\nwendquote} and {\Tt{}selected{\_}\nwendquote} is to cater to
different requirements. We need fast traversal through the glob
matched files through \unix{g}, \unix{n}, and \unix{N} commands. On
the other hand, we need constant time updates of selection status of
files.

\nwenddocs{}\nwbegincode{6}\moddef{FileList implementation}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}Indices definition\RA{}
private \{
  \LA{}File implementation\RA{}
  SafeRange!(FileImpl[],  FileIndex) list_;
  SafeRange!(FileIndex[], ViewIndex) file_;
  SafeRange!(ViewIndex[], FileIndex) view_;
  SafeRange!(FileIndex[], GlobIndex) glob_;
  SafeRange!(bool[], FileIndex)      selected_;
\}

alias list_ this;

\nwendcode{}\nwbegindocs{7}For safe iteration over the files in the file list, we allow the
user to use {\Tt{}foreach\nwendquote} to iterate over the files using {\Tt{}ViewIndex\nwendquote}.

\nwenddocs{}\nwbegincode{8}\moddef{FileList accessor functions}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
int opApply(scope int delegate(ViewIndex) dg) \{
  int result = 0;
  for (auto i = ViewIndex(0);
            i < list_.length;
            ++i) \{
    result = dg(i);
    if (result) break;
  \}
  return result;
\}

\nwendcode{}\nwbegindocs{9}The user may also iterate using a {\Tt{}foreach\nwendquote} over all the glob
matched files.

\nwenddocs{}\nwbegincode{10}\moddef{FileList accessor functions}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
int opApply(scope int delegate(GlobIndex) dg) \{
  int result = 0;
  for (auto i = GlobIndex(0);
            i < glob_.length;
            ++i) \{
    result = dg(i);
    if (result) break;
  \}
  return result;
\}

\nwendcode{}\nwbegindocs{11}The {\Tt{}convert\nwendquote} function will allow the user to convert one type of
index into another. Note that it is not possible to convert from a
file index or a view index to a glob index.

\nwenddocs{}\nwbegincode{12}\moddef{FileList accessor functions}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
To convert(To, From)(in From index) const \{
  static if (is(To == From)) return index;
  
  static if (is(To == FileIndex)) \{
    static if (is(From == ViewIndex)) \{
      return file_[index];
    \} else static if (is(From == GlobIndex)) \{
      return glob_[index];
    \}
  \} else static if (is(To == ViewIndex)) \{
    static if (is(From == FileIndex)) \{
      return view_[index];
    \} else static if (is(From == GlobIndex)) \{
      return convert!To(glob_[index]);
    \}
  \} else \{
    static assert(false, "convert: Unsupported conversion.");
  \}
\}

\nwendcode{}\nwbegindocs{13}We now define various functions that access properties of files such
as name, full path, size etc. These functions can take a {\Tt{}FileIndex\nwendquote}
,{\Tt{}ViewIndex\nwendquote}, or {\Tt{}GlobIndex\nwendquote} as parameter.

\nwenddocs{}\nwbegincode{14}\moddef{FileList accessor functions}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup

template isIndexType(T)
\{
  enum isIndexType =
    is(T == FileIndex) ||
    is(T == ViewIndex) ||
    is(T == GlobIndex);
\}

const \{
  auto name(T)(in T f) if (isIndexType!T)
  \{
    return list_[convert!FileIndex(f)].name;
  \}

  auto path(T)(in T f) if (isIndexType!T)
  \{
    return list_[convert!FileIndex(f)].path;
  \}
  
  auto type(T)(in T f) if (isIndexType!T)
  \{
    return list_[convert!FileIndex(f)].type;
  \}
  
  auto size(T)(in T f) if (isIndexType!T)
  \{
    return list_[convert!FileIndex(f)].size;
  \}
  
  auto mtime(T)(in T f) if (isIndexType!T)
  \{
    return list_[convert!FileIndex(f)].mtime;
  \}
  
  auto atime(T)(in T f) if (isIndexType!T)
  \{
    return list_[convert!FileIndex(f)].atime;
  \}
\}

\nwendcode{}\nwbegindocs{15}We now define the sort method. The {\Tt{}sort\nwendquote} method modifies
{\Tt{}view{\_}\nwendquote} and {\Tt{}file{\_}\nwendquote} arrays to reflect the new ordering. We also
ensure that the list of glob matched files in {\Tt{}glob{\_}\nwendquote} is ordered
consistently with the order in the file list. If the sorting is based
on selection or glob matches, then we simply have to shift those
elements to the front. This can be done in $O(s)$ time where $s$ is
the size of the list to be moved to the beginning by the partitioning
algorithm. Note that we cannot use {\Tt{}std.algorithm.partition\nwendquote} as
checking whether a {\Tt{}FileIndex\nwendquote} is glob matched is an expensive
operation.

\nwenddocs{}\nwbegincode{16}\moddef{FileList modifying functions}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
private void moveToFront(R)(in R s)
  if (isInputRange!R && hasLength!R &&
      is(ElementType!R == FileIndex))
\{
  assert (s.length < file_.length);
  
  auto i = ViewIndex(0);
  foreach (e; s) \{
    auto tf   = file_[i];
    auto tv   = view_[e];
    file_[i]  = e;
    view_[e]  = i;
    file_[tv] = tf;
    view_[tf] = tv;
    i++;
  \}
\}

enum SortField
\{
  NAME,
  MTIME,
  ATIME,
  SIZE,
  GLOB,
  SELECT,
  FILETYPE
\}

void sort(SortField sf)()
  if (sf == GLOB)
\{
  moveToFront(glob_);
\}

void sort(SortField sf)()
  if (sf == SELECT)
\{
  auto s = &this.isSelected!FileIndex;
  algo.partition!(s, algo.SwapStrategy.stable)(vanillaIndexed(file_));
  algo.partition!(s, algo.SwapStrategy.stable)(vanillaIndexed(glob_));
  fixupView();
\}

\nwendcode{}\nwbegindocs{17}For the other sort fields, we simply sort based on the {\Tt{}<\nwendquote}
operator of corresponding fields. The {\Tt{}fixupView\nwendquote} method ensures
that the {\Tt{}view{\_}\nwendquote} array encodes the inverse permutation of
{\Tt{}file{\_}\nwendquote}.

\nwenddocs{}\nwbegincode{18}\moddef{FileList modifying functions}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
private bool fileLess(SortField sf)(in FileIndex i, in FileIndex j)
\{
  switch (sf) \{
    case NAME:     return name(i)  < name(j);
    case MTIME:    return mtime(i) < mtime(j);
    case ATIME:    return atime(i) < atime(j);
    case SIZE:     return size(i)  < size(j);
    case FILETYPE: return type(i)  < type(j);
    default: assert(false, "BUG: Invalid sort field\\n");
  \}
\}

private void fixupView()
\{
  auto i = ViewIndex(0);
  foreach (f; file_) \{
    view_[f] = i;
    i++;
  \}
\}

void sort(SortField sf)()
  if (sf == NAME     ||
      sf == FILETYPE ||
      sf == MTIME    ||
      sf == ATIME    ||
      sf == SIZE)
\{
  auto less   = &this.fileLess!sf;
  algo.sort!(less, algo.SwapStrategy.stable)(vanillaIndexed(file_));
  algo.sort!(less, algo.SwapStrategy.stable)(vanillaIndexed(glob_));
  fixupView();
\}

\nwendcode{}\nwbegindocs{19}The {\Tt{}reverse\nwendquote} method reverses the order of files as seen by the
user.

\nwenddocs{}\nwbegincode{20}\moddef{FileList modifying functions}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
void reverse()
\{
  algo.reverse(vanillaIndexed(file_));
  algo.reverse(vanillaIndexed(glob_));
  fixupView();
\}

\nwendcode{}\nwbegindocs{21}The {\Tt{}glob\nwendquote} method fills the array {\Tt{}glob{\_}\nwendquote} with the list of files
matching the input glob pattern.

\nwenddocs{}\nwbegincode{22}\moddef{FileList modifying functions}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
void glob(in string pattern)
\{
  glob_ = [];
  foreach (f; file_) \{
    if (globMatch(name(f), pattern)) \{
      glob_ ~= f;
    \}
  \}
\}

\nwendcode{}\nwbegindocs{23}We also provide access to the number of glob matches through a
property.

\nwenddocs{}\nwbegincode{24}\moddef{FileList accessor functions}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
@property
auto globMatches() const
\{
  return glob_.length;
\}

\nwendcode{}\nwbegindocs{25}We now define methods to manipulate the current selection. We
maintain a bitmap to store the current selection. This makes the
property {\Tt{}selected\nwendquote} require time that is linear in the number of all
files, as opposed to time linear in the number of selected
files. However, the operations of selecting, deselecting, and querying
whether a file is selected is constant time.

\nwenddocs{}\nwbegincode{26}\moddef{FileList modifying functions}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
void select(T)(in T f) if (isIndexType!T)
\{
  selected_[convert!FileIndex(f)] = true;
\}

void deselect(T)(in T f) if (isIndexType!T)
\{
  selected_[convert!FileIndex(f)] = false;
\}

bool isSelected(T)(in T f) const if (isIndexType!T)
\{
  return selected_[convert!FileIndex(f)];
\}

\nwendcode{}\nwbegindocs{27}We have to ensure that the {\Tt{}selected\nwendquote} range is sorted according to
the user's view. For this, we can simply filter the file indices from
the {\Tt{}file{\_}\nwendquote} array. Recall that {\Tt{}file{\_}[0]\nwendquote} is the first file seen
by the user.

\nwenddocs{}\nwbegincode{28}\moddef{FileList modifying functions}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
@property
auto selected()
\{
  auto pred = &this.isSelected!FileIndex;
  return algo.filter!(pred)(vanillaIndexed(file_));
\}

\nwendcode{}\nwbegindocs{29}We will allow creation of a {\Tt{}FileList\nwendquote} by specifying a directory
or the list of files. After we finish fetching information about all
files in the directory, skipping errors if any, we set up the
{\Tt{}file{\_}\nwendquote} and {\Tt{}view{\_}\nwendquote} arrays to identity permutations.

\nwenddocs{}\nwbegincode{30}\moddef{FileList creation}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
static FileList loadDirectory(in string path)
\{
  FileList result;

  auto files = dirEntries(path, SpanMode.shallow);

  foreach (f; files) \{
    continueOnError(
      \{ result.list_ ~= FileImpl(f); \}(),
      "sf: Failed to load " ~ f.name
    );
  \}

  \LA{}Initialize rest of FileList result\RA{}
  return result;
\}

\nwendcode{}\nwbegindocs{31}Another way to create a {\Tt{}FileList\nwendquote} is by specifying the names of
all files explicitly.

\nwenddocs{}\nwbegincode{32}\moddef{FileList creation}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
static FileList fromPaths(in string[] paths)
\{
  FileList result;

  result.list_.reserve(paths.length);

  foreach (p; paths) \{
    continueOnError(
      \{ result.list_ ~= FileImpl(p); \}(),
      "sf: Failed to load " ~ p
    );
  \}
  \LA{}Initialize rest of FileList result\RA{}
  return result;
\}

\nwendcode{}\nwbegindocs{33}The following code initializes the rest of the {\Tt{}FileList\nwendquote} struct
assuming that the {\Tt{}list{\_}\nwendquote} field is properly initialized.

\nwenddocs{}\nwbegincode{34}\moddef{Initialize rest of FileList result}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
if (result.list_.length > 0) \{
  result.view_.reserve(result.list_.length);
  result.file_.reserve(result.list_.length);

  result.selected_ = new bool[result.list_.length];
  result.view_     = array(
                      iota(
                      ViewIndex(0),
                      ViewIndex(result.list_.length)));
  result.file_     = array(
                      iota(
                       FileIndex(0),
                       FileIndex(result.list_.length)));
\}

\nwendcode{}\nwbegindocs{35}Finally, we combine all the above to define our {\Tt{}FileList\nwendquote}
datatype.

\nwenddocs{}\nwbegincode{36}\moddef{FileList definition}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
struct FileList
\{
  \LA{}FileList implementation\RA{}
  \LA{}FileList accessor functions\RA{}
  \LA{}FileList modifying functions\RA{}
  \LA{}FileList creation\RA{}
\}

\nwendcode{}\nwbegindocs{37}The second major component of our program will be the user
interface. We will use ncurses for our UI. Each UI element in ncurses
is defined by a rectangle. The {\Tt{}x,\ y\nwendquote} coordinates will describe the
location of the top left corner.

\nwenddocs{}\nwbegincode{38}\moddef{MainUI variables}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
static struct Rectangle \{
  int height;
  int width;
  int x;
  int y;
  WINDOW *win;
\}

Rectangle screen;
Rectangle fileListWin;
Rectangle fileListPad;
Rectangle echoWin;

\nwendcode{}\nwbegindocs{39}The full screen is desribed by the rectangle {\Tt{}screen\nwendquote}. The
rectangles {\Tt{}echoWin\nwendquote} and {\Tt{}fileListWin\nwendquote} describes the echo area and the file list area. Our UI consists of two parts: the file list and
the echo area. The file list displays the list of files (or a part of
it) in the user-specified order. The echo area is for interacting with
the user. The file list window will occupy all but the last line of
the user's screen. The last line will be occupied by the window
{\Tt{}echoWin\nwendquote}.

The ncurses pad {\Tt{}fileListPad\nwendquote} contains a framebuffer representation
of the file list. If there are $n$ files in the file list, then the
first $n$ lines in the pad will be occupied by those files. We
allocate a buffer space of {\Tt{}height\nwendquote} lines where {\Tt{}height\nwendquote} is the
number of lines in the file list window. This simplifies the logic in
{\Tt{}show\nwendquote} function by allowing us to simply project {\Tt{}height\nwendquote} lines
from the first file to be displayed on the screen.

\nwenddocs{}\nwbegincode{40}\moddef{Initialize UI components}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
int x, y;

getmaxyx(stdscr, y, x);
screen.height = y + 1;
screen.width  = x + 1;
screen.x      = 0;
screen.y      = 0;
screen.win    = stdscr;

fileListWin.height = screen.height - 1;
fileListWin.width  = screen.width;
fileListWin.x      = screen.x;
fileListWin.y      = screen.y;
fileListWin.win    = subwin(screen.win,
  fileListWin.height,
  fileListWin.width,
  fileListWin.y,
  fileListWin.x);

echoWin.height = 1;
echoWin.width  = screen.width;
echoWin.x      = screen.x;
echoWin.y      = screen.y + fileListWin.height;
echoWin.win    = subwin(stdscr,
  echoWin.height,
  echoWin.width,
  echoWin.y,
  echoWin.x);
enforce(
  OK == keypad(echoWin.win, true),
  "sf: Failed to initialize UI."
);

fileListPad.height = cast(int)fileList.length + fileListWin.height;
fileListPad.width  = screen.width;
fileListPad.x      = 0;
fileListPad.y      = 0;
fileListPad.win    = newpad(
  fileListPad.height,
  fileListPad.width);

\nwendcode{}\nwbegindocs{41}The window {\Tt{}fileListWin\nwendquote} will display the appropriate portion of
the pad. The variable {\Tt{}first\nwendquote} contains the view index of the the
first file to be displayed.

\nwenddocs{}\nwbegincode{42}\moddef{show function}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
private void show() \{
  int sminrow, smincol, smaxrow, smaxcol;
  int fst = cast(int)first;

  assert(fst >= 0);

  sminrow = fileListWin.y;
  smincol = fileListWin.x;
  
  int nfiles = cast(int)fileList.length - fst;

  smaxrow = sminrow + fileListWin.height - 1,
  smaxcol = smincol + fileListWin.width  - 1;
  
  prefresh(fileListPad.win,
           fst,
           0,
           sminrow,
           smincol,
           smaxrow,
           smaxcol);
\}

\nwendcode{}\nwbegindocs{43}To transfer the file list onto the frame buffer, we simply print out
the information of each file line by line in the view index order. The
file at view index {\Tt{}v\nwendquote} is always written to the line {\Tt{}v\nwendquote} in the
file list pad.

\nwenddocs{}\nwbegincode{44}\moddef{Write the file at ViewIndex v into the file list pad}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
auto i = toInt(v);
auto line = formatFile.print(this.fileList, v);
wmove(fileListPad.win, i, 0);
wclrtoeol(fileListPad.win);
auto ncline = dstringz(line);
waddwstr(fileListPad.win, ncline);
free(ncline);

\nwendcode{}\nwbegindocs{45}We will provide overloads for reloading the entire file list into
the pad or only specific files.

\nwenddocs{}\nwbegincode{46}\moddef{reloadPad function}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
private void reloadPad()
\{
  foreach (ViewIndex v; fileList) \{
    \LA{}Write the file at ViewIndex v into the file list pad\RA{}
  \}
\}

private void reloadPad(R)(R files)
  if (isInputRange!R && is(ElementType!R == ViewIndex))
\{
  foreach (ViewIndex v; files) \{
    \LA{}Write the file at ViewIndex v into the file list pad\RA{}
  \}
\}

\nwendcode{}\nwbegindocs{47}The following code determine how a file is actually displayed in the
UI. We want the display to be easily configurable. The {\Tt{}FieldSpec\nwendquote}
is an abstract base class that can be overriden to specify how to
display fields. For ex., the {\Tt{}name\nwendquote} function takes the preferred
field width in percentage and minimum width as parameters and returns
an instance of {\Tt{}FieldSpec\nwendquote} that overrides {\Tt{}print\nwendquote} to print the
name of the given file within the specified width. Note that the
{\Tt{}realWidth\nwendquote} field is filled in later by the function
{\Tt{}makeFileFormat\nwendquote} based on the requested preferred and min widths.

\nwenddocs{}\nwbegincode{48}\moddef{File display routines}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
private static class FieldSpec
\{
  Percent preferredWidth;
  int     minWidth;
  int     realWidth;

  this(Percent p, int min) \{
    preferredWidth = p;
    minWidth = min;
  \}

  string print(in FileList fl, in ViewIndex v) \{
    assert(0);
  \}
\}

private static auto name(Percent p, int min)
\{
  return new class FieldSpec \{
    this() \{ super(p, min); \}
    override string print(in FileList fl, in ViewIndex v)
    \{
      auto w = to!string(realWidth);
      return format("%-" ~ w ~ "." ~ w ~ "s",
                    sanitize(fl.name(v)));
    \}
  \};
\}

private static auto line(Percent p, int min)
\{
  return new class FieldSpec \{
    this() \{ super(p, min); \}
    override string print(in FileList fl, in ViewIndex v)
    \{
      auto w = to!string(realWidth);
      return format("%-" ~ w ~ "d", v);
    \}
  \};
\}

private static auto space(int n = 1)
\{
  return new class FieldSpec \{
    this() \{ super(0.percent, n); \}
    override string print(in FileList fl, in ViewIndex v)
    \{
      return " ";
    \}
  \};
\}

private static auto selected(string marker)
\{
  return new class FieldSpec \{
    this() \{ super(0.percent, 1); \}
    override string print(in FileList fl, in ViewIndex v)
    \{
      auto selectedp = &fl.isSelected!ViewIndex;
      return selectedp(v) ? marker : " ";
    \}
  \};
\}

private auto fcurrent(string marker)
\{
  return new class FieldSpec \{
    this() \{ super(0.percent, 1); \}
    override string print(in FileList fl, in ViewIndex v)
    \{
      return current == v ? marker : " ";
    \}
  \};
\}

private static auto size(Percent p, int min)
\{
  return new class FieldSpec \{
    this() \{ super(p, min); \}
    override string print(in FileList fl, in ViewIndex v)
    \{
      return format("%" ~ to!string(realWidth) ~ "d", fl.size(v));
    \}
  \};
\}

\nwendcode{}\nwbegindocs{49}The main UI stores some state related to the file list such as the
file list itself, the current file, and the current glob matched file
in a glob search (which is null if there no glob search has been done
yet).

\nwenddocs{}\nwbegincode{50}\moddef{MainUI variables}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
FileList fileList;
ViewIndex current = ViewIndex(0);
Nullable!GlobIndex globCurrent;
bool writeFiles = false;
FILE* infile;
FILE* outfile;

\nwendcode{}\nwbegindocs{51}The {\Tt{}formatFile\nwendquote} variable stores a {\Tt{}FieldSpec\nwendquote} instance that
prints all the fields. The function {\Tt{}makeFileFormat\nwendquote} is a helper
function that can be used to create formatting functions. This
function accepts a list of {\Tt{}FieldSpec\nwendquote} objects. For example, The
call {\Tt{}makeFileFormat(\nwendquote}{\Tt{}line(10.percent,\ 5),\nwendquote}{\Tt{}\ name(90.percent,\nwnewline
20))\nwendquote} creates a file formatter that uses the first 10 percent of line
width to display the line number and the remaining 90 percent to
display the file name.

\nwenddocs{}\nwbegincode{52}\moddef{MainUI variables}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
FieldSpec formatFile;

FieldSpec makeFileFormat(FieldSpec[] args...)
\{
  int total;

  foreach (arg; args) \{
    arg.realWidth = lbound(
      (arg.preferredWidth.value * fileListWin.width) / 100,
      arg.minWidth);
    total += arg.realWidth;
  \}

  enforce(
    total <= fileListWin.width,
    "sf: screen not wide enough to display files."
  );

  return new class FieldSpec \{
    this() \{ super(100.percent, fileListWin.width); \}
    override string print(in FileList fl, in ViewIndex v) \{
      string result;
      foreach (arg; args) \{
        result ~= arg.print(fl, v);
      \}
      return result;
    \}
  \};
\}

\nwendcode{}\nwbegindocs{53}The variable {\Tt{}sink\nwendquote} is the sink function that consumes the range
of selected files. It is called if the user pressed 'q' to exit the
application.

\nwenddocs{}\nwbegincode{54}\moddef{MainUI variables}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
alias SinkType =
  void function(InputRange!(const(string)) files);
SinkType sink;

\nwendcode{}\nwbegindocs{55}Now we define the {\Tt{}MainUI\nwendquote} structure. Constructing a MainUI object
starts the UI. The {\Tt{}FileList\nwendquote} and {\Tt{}SinkType\nwendquote} parameters are the
file list that the UI should display and the function to call to
output the selected files. The UI is teared down when the destructor
is called.

\nwenddocs{}\nwbegincode{56}\moddef{MainUI definition}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
struct MainUI
\{
  \LA{}MainUI variables\RA{}
  
  this(FileList fl, SinkType s) \{
    fileList = fl;
    sink     = s;

    setlocale(LC_ALL, "");

    infile  = fopen("/dev/tty", "rb");
    scope (failure) fclose(infile);
    
    outfile = fopen("/dev/tty", "wb");
    scope (failure) fclose(outfile);
    
    enforce(
      newterm(cast(char*)null, outfile, infile),
      "sf: Failed to initialize UI."
    );

    scope (failure) endwin();
    
    // endwin() restores everything if anything follows fails.
    
    enforce(
      OK == noecho() &&
      OK == nonl()   &&
      ERR != curs_set(0),
      "sf: Failed to initialize UI."
    );
    
    \LA{}Initialize UI components\RA{}

    formatFile = makeFileFormat(
      line(0.percent, 5),
      fcurrent(">"),
      space(),
      selected("*"),
      space(),
      name(50.percent, 15),
      size(15.percent, 10)
    );

    reloadPad();
    show();
    loop();
  \}

  ~this() \{
    endwin();
    fclose(infile);
    fclose(outfile);
    if (writeFiles) \{
        sink(inputRangeObject(
               algo.map!(f => fileList.path(f))
                        (fileList.selected)
             )
        );
    \}
  \}

  \LA{}show function\RA{}
  \LA{}Echo area functions\RA{}
  \LA{}reloadPad function\RA{}
  \LA{}File display routines\RA{}
  \LA{}loop function\RA{}
\}

\nwendcode{}\nwbegindocs{57}The echo window can be accessed programmatically in the following
ways: The function {\Tt{}readKey\nwendquote} reads a character entered by the user,
the function {\Tt{}writeChar\nwendquote} writes the character to the current
position in the echo area taking care of writing past the last
position in the window, the function {\Tt{}clearEcho\nwendquote} clears the echo
area.

\nwenddocs{}\nwbegincode{58}\moddef{Echo area functions}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
auto readKey()
\{
  dchar c;
  enforce(
    wget_wch(echoWin.win, &c) == OK,
    "sf: Failed to initialize UI."
  );
  return c;
\}

void writeChar(dchar ch)
\{
  writeStr(to!string(ch));
\}

void writeStr(string s)
\{
  waddstr(echoWin.win, toStringz(s));
\}

void clearEcho()
\{
  wclear(echoWin.win);
\}

void pushBackKey(dchar ch)
\{
  unget_wch(ch);
\}

\nwendcode{}\nwbegindocs{59}Now we describe our command processing loop. The input to the
command processor is a stack based programming language. We support
the following data types: double-quoted strings, single-quote
preceeded characters, natural numbers, and marks which are positions
in the file list. The commands look at the top of the stack for
arguments. For example, the {\Tt{}j\nwendquote} command looks for a number at the
top of the stack and if it does not find one, uses the default value
of 1. The variable {\Tt{}top\nwendquote} points to the next empty spot in the
stack. Notice that all casts in the {\Tt{}set()\nwendquote} are safe as long as we
do not modify values on the stack.

\nwenddocs{}\nwbegincode{60}\moddef{Data stack definition}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
static struct DataStack(size_t nelems) \{
  static struct DataStackElem \{
    enum _Type \{ NODATA, NUM, STR, CH, MARK \}

    _Type type;
  
    union _Data \{
      int num;
      string str;
      dchar ch;
    \}

    _Data data;
  
    alias data this;
    
    void set(T, _Type t = _Type.NODATA)(in T data) \{
      static if (is(T == int)) \{
        static assert(t != _Type.NODATA,
          "DataStackElem: Specify type of int.");
        type = t;
        num  = cast(int)data;
      \} else static if (is(T == string)) \{
        type = STR;
        str = cast(string)data;
      \} else static if (is(T == dchar)) \{
        type = CH;
        ch = cast(dchar)data;
      \} else \{
        static assert(false,
          "DataStackElem: Unsupported data type.");
      \}
    \}

    string toString() const \{
      final switch (type) \{
      case _Type.NUM:    return to!string(num);
      case _Type.STR:    return "\\"" ~ to!string(str) ~ "\\"";
      case _Type.CH:     return "\\'" ~ to!string(ch);
      case _Type.MARK:   return to!string(num) ~ "m";
      case _Type.NODATA: assert(0);
      \}
    \}
  \}

  DataStackElem[nelems] stack;
  int top = 0;

  alias SType = DataStackElem._Type;

  template STypeToType(SType t) \{
    static if (t == SType.NUM || t == SType.MARK)
      alias STypeToType = int;
    else static if (t == SType.CH)
      alias STypeToType = dchar;
    static if (t == SType.STR)
      alias STypeToType = string;
  \}

  void push(SType t, T = STypeToType!t)(in T d)
  \{
    assert (top < nelems);
    stack[top].set!(T, t)(d);
    ++top;
  \}

  auto pop(SType t)()
  \{
    Nullable!(STypeToType!t) result;

    if (top == 0) return result;
    if (t == stack[top - 1].type) \{
      static if (t == SType.NUM ||
                 t == SType.MARK) \{
        --top;
        result = stack[top].num;
      \} else static if (t == SType.STR) \{
        --top;
        result = stack[top].str;
      \} else static if (t == SType.CH) \{
        --top;
        result = stack[top].ch;
      \} else \{
        static assert(false, "pop: Invalid type.");
      \}
    \}
    return result;
  \}

  auto peek()
  \{
    Nullable!DataStackElem result;
    if (top > 0) \{
      result = stack[top - 1];
    \}
    return result;
  \}

  void popAny()
  \{
    if (top > 0) --top;
  \}
\}

DataStack!100 dataStack;

alias SType  = dataStack.SType;
alias NUM    = SType.NUM;
alias MARK   = SType.MARK;
alias CH     = SType.CH;
alias STR    = SType.STR;
alias NODATA = SType.NODATA;

\nwendcode{}\nwbegindocs{61}The words in the programming language are grouped into data or
commands. The start state can determine the type of the word by only
looking at the first non-blank character. If it is a " or ' or a
number, then it's data, otherwise it must be a valid command.

\nwenddocs{}\nwbegincode{62}\moddef{States of the command processor}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
enum \{
  START,
  READ_CH,
  READ_STR,
  READ_NUM,
  READ_COMMAND,
  QUIT
\}

int state = START;

\nwendcode{}\nwbegindocs{63}The character {\Tt{}c\nwendquote} is used to read the current character input by
the user.

\nwenddocs{}\nwbegincode{64}\moddef{Local variables for command processor}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
dchar c;

\nwendcode{}\nwbegindocs{65}The command processor works in iterations. In each iteration, it
reads a key from the user and forwards the key to the appropriate
state. The state handles the key and sets the next state. The command
processor should echo the data item being entered by the user to
provide feedback.

\nwenddocs{}\nwbegincode{66}\moddef{Setup state for the command processor}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
c   = cast(dchar)readKey();

\nwendcode{}\nwbegindocs{67}The start state simply looks at the key and delegates to the
appropriate state to handle the key.

\nwenddocs{}\nwbegincode{68}\moddef{Start state}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
case START:
  clearEcho();
  if (c.isWhite) \{
    state = START;
  \} else if (c == '\\"') \{
    s = "";
    writeChar('\\"');
    state = READ_STR;
  \} else if (c == '\\'') \{
    writeChar('\\'');
    state = READ_CH;
  \} else if (c.isDigit) \{
    n = 0;
    pushBackKey(c);
    state = READ_NUM;
  \} else \{
    pushBackKey(c);
    state = READ_COMMAND;
  \}
  break;

\nwendcode{}\nwbegindocs{69}Processing a data item is straight-forward. Simply read it and push
it onto the stack. The variables {\Tt{}n\nwendquote} and {\Tt{}s\nwendquote} are used to keep
track of the number and string input the user.

\nwenddocs{}\nwbegincode{70}\moddef{Local variables for command processor}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
int n;
string s;

\nwendcode{}\nwbegincode{71}\moddef{Read data items}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
case READ_CH:
  writeChar(c);
  dataStack.push!CH(c);
  state = START;
  break;

case READ_STR:
  if (c != '\\"') \{
    writeChar(c);
    s ~= c;
  \} else \{
    writeChar('\\"');
    dataStack.push!STR(s);
    state = START;
  \}
  break;

case READ_NUM:
  if (c.isDigit) \{
    writeChar(c);
    n = n * 10 + charToInt(c);
  \} else \{
    dataStack.push!NUM(n);
    pushBackKey(c);
    state = START;
  \}
  break;

\nwendcode{}\nwbegindocs{72}Now we process the commands. All commands are single letter
commands. So we simply have to look at the character, pop the
appropriate data items from the stack, and update the file list. All
commands being single letter also allows us to put the state
transition outside the command handling {\Tt{}switch\nwendquote} statement.

\nwenddocs{}\nwbegincode{73}\moddef{Read commands}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
case READ_COMMAND:
  switch (c) \{
    \LA{}Handle commands\RA{}
  \}
  state = START;
  break;

default: assert(0);

\nwendcode{}\nwbegindocs{74}The reverse command.

\nwenddocs{}\nwbegincode{75}\moddef{Handle commands}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
case 'r':
  fileList.reverse(); break;

\nwendcode{}\nwbegindocs{76}Handle motion commands. This part illustrates why mark and number
has to be separate data types. If they were the same, any \unix{j} or
\unix{k} after \unix{m} will consume the pushed mark which is not what
we would want. The right behaviour is to save the mark until the next
\unix{;} command (or, more importantly, one of the selection commands
which uses the mark to specify the range of files).

\nwenddocs{}\nwbegincode{77}\moddef{Handle commands}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
case 'j':
  setCurrent(cur + dataStack.pop!NUM().ifNull(1));
  break;
case 'k':
  setCurrent(cur - dataStack.pop!NUM().ifNull(1));
  break;
case ';':
  auto x = dataStack.pop!MARK();
  if (x.isNull) \{
    x = dataStack.pop!NUM();
  \}
  auto dest = x.ifNull(0);
  setCurrent(dest);
  break;
case 'm':
  dataStack.push!MARK(cur);
  break;

\nwendcode{}\nwbegindocs{78}For the selection commands, we first check the stack to see whether
some position is marked. If a mark is present, we select/deselect all
files from the mark to the current position (both inclusive). If a
mark is not present, then we select/deselect the current file. The
range {\Tt{}[beg,\ end)\nwendquote} specifies the files to be selected.

\nwenddocs{}\nwbegincode{79}\moddef{Local variables for command processor}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
int m, beg, end;

\nwendcode{}\nwbegincode{80}\moddef{Obtain range of files}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
m = dataStack.pop!MARK().ifNull(cur);

if (m > cur) \{
  beg = cur;
  end = m + 1;
\} else \{
  beg = m;
  end = cur + 1;
\}

\nwendcode{}\nwbegincode{81}\moddef{Handle commands}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
case 's':
  \LA{}Obtain range of files\RA{}
  foreach (v; beg .. end) \{
    auto v1 = ViewIndex(v);
    fileList.select(v1);
  \}
  break;
case 'S':
  \LA{}Obtain range of files\RA{}
  foreach (v; beg .. end) \{
    auto v1 = ViewIndex(v);
    fileList.deselect(v1);
  \}
  break;
case 't':
  \LA{}Obtain range of files\RA{}
  foreach (v; beg .. end) \{
    auto v1 = ViewIndex(v);
    if (fileList.isSelected(v1))
      fileList.deselect(v1);
    else
      fileList.select(v1);
  \}
  break;

\nwendcode{}\nwbegindocs{82}The sort command accepts an argument on the stack that specifies the
sort field. We use the file name as the default sort field.

\nwenddocs{}\nwbegincode{83}\moddef{Handle commands}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
case 'a':
  auto sortarg = dataStack.pop!CH().ifNull(dchar('n'));
  switch (sortarg) \{
    case 'n': fileList.sort!(NAME);     break;
    case 'm': fileList.sort!(MTIME);    break;
    case 'a': fileList.sort!(ATIME);    break;
    case 's': fileList.sort!(SIZE);     break;
    case 'g': fileList.sort!(GLOB);     break;
    case 'u': fileList.sort!(SELECT);   break;
    case 't': fileList.sort!(FILETYPE); break;
    default:  break;
  \}
  break;

\nwendcode{}\nwbegindocs{84}The glob command simply delegates the actual glob search to the
underlying file list. The main work is to maintain {\Tt{}globCurrent\nwendquote} and
{\Tt{}current\nwendquote}.

\nwenddocs{}\nwbegincode{85}\moddef{Handle commands}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
case 'g':
  string globarg = dataStack.pop!STR().ifNull("");
  fileList.glob(globarg);
  if (fileList.globMatches) \{
    setGlobCurrent(0);
    setCurrent(
      toInt(fileList
            .convert!ViewIndex(
              globCurrent.get)));
  \}
  state = START;
  break;

case 'n':
  if (!globCurrent.isNull) \{
    auto g = toInt(globCurrent.get);
    setGlobCurrent(g + 1);
    setCurrent(
      toInt(fileList
            .convert!ViewIndex(
              globCurrent.get)));
  \}
  state = START;
  break;

case 'N':
  if (!globCurrent.isNull) \{
    auto g = toInt(globCurrent.get);
    setGlobCurrent(g - 1);
    setCurrent(
      toInt(fileList
            .convert!ViewIndex(
              globCurrent.get)));
  \}
  state = START;
  break;

\nwendcode{}\nwbegindocs{86}Quit command.

\nwenddocs{}\nwbegincode{87}\moddef{Handle commands}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
case 'q':
  writeFiles = true;
  goto quit;

case 'Q':
  writeFiles = false;
  goto quit;

\nwendcode{}\nwbegincode{88}\moddef{Handle commands}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
default: break; // Unknown command letter.

\nwendcode{}\nwbegindocs{89}We define some commands to manipulate the data stack. The peek
command prints the top stack element in the echo area. The pop command
pops the top stack element.

\nwenddocs{}\nwbegincode{90}\moddef{Handle commands}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
case 'p':
  clearEcho();
  auto top = dataStack.peek();
  if (!top.isNull) \{
    writeStr(top.get.toString());
  \}
  break;
case 'P':
  dataStack.popAny();
  break;

\nwendcode{}\nwbegindocs{91}The following are convenience functions used by our command
processor.

\nwenddocs{}\nwbegincode{92}\moddef{Convenience functions for command processor}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
void setCurrent(in int newcur)
\{
  alias VI = ViewIndex;
  current = VI(bound(
                 newcur,
                 0,
                 cast(int)fileList.length - 1));
\}

@property
int cur()
\{
  return toInt(current);
\}

void setGlobCurrent(in int newcur)
\{
  alias GI = GlobIndex;
  globCurrent = GI(bound(
                 newcur,
                 0,
                 cast(int)fileList.globMatches - 1));
\}

static int charToInt(in dchar c)
\{
  assert(c.isDigit);
  return c - '0';
\}

\nwendcode{}\nwbegindocs{93}Finally, we put everything together to make our command processor.

\nwenddocs{}\nwbegincode{94}\moddef{loop function}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
void loop()
\{
  \LA{}Convenience functions for command processor\RA{}
  \LA{}Local variables for command processor\RA{}
  \LA{}Data stack definition\RA{}
  \LA{}States of the command processor\RA{}

  while (true) \{
    \LA{}Setup state for the command processor\RA{}
    switch(state) \{
      \LA{}Start state\RA{}
      \LA{}Read data items\RA{}
      \LA{}Read commands\RA{}
    \}
    \LA{}Display the appropriate portion of file list pad\RA{}
  \}

quit: return;
\}

\nwendcode{}\nwbegindocs{95}We will now describe our main redrawing logic. The current file has
to be displayed always. If the file list window has $n$ lines, then we
have to determine the appropriate $n$ files to reload into the file
list pad and project on to the window. We keep track of the view index
of the first file displayed. From this and the $n$, we can determine
whether the current file is displayed or not. If the current file is
not displayed, then we have to change the first file displayed so that
the current file is displayed.

If the user has scrolled down too far, then we arrange things so that
the current file is displayed approximately 1/5 from the beginning of
the screen. If the user has scrolled up too far, then we arrange
things so that the current file is displayed approximately 4/5 from
the end of the screen.

\nwenddocs{}\nwbegincode{96}\moddef{MainUI variables}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
ViewIndex first = ViewIndex(0);

\nwendcode{}\nwbegincode{97}\moddef{Display the appropriate portion of file list pad}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
int nlines = fileListWin.height;

if (current < first) \{
  first = ViewIndex(lbound(cur - 4 * nlines/5, 0));
\} else if (cur >= first + nlines) \{
  first = ViewIndex(lbound(cur - nlines/5, 0));
\}

ViewIndex last = ViewIndex(
  ubound(toInt(first) + nlines,
         cast(int)fileList.length));
reloadPad(iota(first, last));
show();

\nwendcode{}\nwbegindocs{98}Now we will write some output routines that print the files selected
into standard output in various common formats.

\nwenddocs{}\nwbegincode{99}\moddef{Output routines}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
alias IRS = InputRange!(const(string));

void printn(IRS files)
\{
  foreach (f; files) writeln(f);
\}

void printq(IRS files)
\{
  foreach (f; files) \{
    write("\\""); write(f); write("\\"");
    write(" ");
  \}
\}

void printz(IRS files)
\{
  foreach (f; files) \{
    write(f);
    write("\\0");
  \}
\}

\nwendcode{}\nwbegindocs{100}Our application.

\nwenddocs{}\nwbegincode{101}\moddef{sf.d}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}Import statements\RA{}
\LA{}Definitions for index and array types\RA{}
\LA{}Convenience functions\RA{}
\LA{}FileList definition\RA{}
\LA{}Useful aliases\RA{}
\LA{}MainUI definition\RA{}
\LA{}Output routines\RA{}

void main(string[] args)
\{
  enum OutputFormat \{
  n,
  q,
  z,
  \}

  OutputFormat outFormat = OutputFormat.n;

  auto ohelp = r"Output format
    n - One file per-line. Assumes there are no newlines in filenames. (default)
    q - Double-quoted, separated by spaces.
    z - Separated by null bytes.";

  auto proghelp =
  r"sf <options> [<dir>]: Select files from <dir> or current directory.
sf <options> -: Select files from the list of files in standard input.";

  auto helpInformation =
    getopt(args,
     config.passThrough,
     "output|o", ohelp, &outFormat
    );

  if (helpInformation.helpWanted) \{
    defaultGetoptPrinter(proghelp,
      helpInformation.options);
    return;
  \}

  FileList fl =
  quitOnError(
    \{
      if (args.length > 1) \{
        if (args[$ - 1] == "-") \{
          return FileList.fromPaths(stdin.byLineCopy.array);
        \} else \{
          return FileList.loadDirectory(args[$-1]);
        \}
      \} else \{
        return FileList.loadDirectory(".");
      \}
    \}(),
    "sf: Failed to load file list."
  );

  quitIf(fl.length == 0,
         "sf: No files to select.");

  auto sink = 
  \{
    final switch (outFormat) \{
    case OutputFormat.n:
      return &printn;
    case OutputFormat.q:
      return &printq;
    case OutputFormat.z:
      return &printz;
    \}
  \}();

  try \{
    MainUI(fl, sink);
  \} catch (Exception e) \{
    stderr.writeln(e.msg);
  \}
\}

\nwendcode{}\nwbegincode{102}\moddef{Import statements}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
import std.string    : toStringz;
import std.stdio     : writeln, write, stderr, stdin;
import std.format    : format;
import std.file      : DirEntry, dirEntries,
                       SpanMode, FileException;
import std.path      : baseName, extension, globMatch;
import std.traits    : isAssignable, TemplateOf;
import std.range     : isInputRange, isRandomAccessRange,
                       ElementType, hasSlicing, hasLength,
                       iota, InputRange, inputRangeObject;
import std.array     : array;
import std.ascii     : isWhite, isDigit;
import std.typecons  : Nullable;
import std.getopt    : defaultGetoptPrinter, getopt, config;
import std.conv      : to, dtext;
import std.exception : enforce;
import std.encoding  : sanitize;

import core.stdc.stdlib : exit, malloc, free;
import core.stdc.stdio  : FILE, fopen, fclose;
import core.stdc.locale : setlocale, LC_ALL;

import algo = std.algorithm;
import deimos.ncurses;

\nwendcode{}\nwbegindocs{103}Now we define the various index and array types. The type
{\Tt{}indexType!(s)\nwendquote}, where {\Tt{}s\nwendquote} is a literal string, is a distinct
index type for distinct strings. We disallow the possibility of mixing
up conceptually distinct index types by overloading assignment in
index types and using {\Tt{}SafeRange\nwendquote} in place of normal arrays. The
function call {\Tt{}vanillaIndexed(array)\nwendquote} allows one to use plain
{\Tt{}size{\_}t\nwendquote} to index any array that can only be indexed using one of
the special index types. This is useful to interface with standard
library functions which expects all random access ranges to be
indexable using {\Tt{}size{\_}t\nwendquote}.

\nwenddocs{}\nwbegincode{104}\moddef{Definitions for index and array types}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
struct Index(string cookie)
\{
  size_t i_;
  alias i_ this;
  Index opBinary(string op)(in int rhs)
  \{
    Index other = this;
    mixin("other.i_ = i_ " ~ op ~ " rhs;");
    return other;
  \}
  auto ref opAssign(in Index other)
  \{
    i_ = other.i_;
  \}
\}

\nwendcode{}\nwbegindocs{105}We will also allow to convert an index into an {\Tt{}int\nwendquote}.

\nwenddocs{}\nwbegincode{106}\moddef{Definitions for index and array types}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
int toInt(T : Index!s, alias s)(in T x)
\{
  return cast(int)x;
\}

struct SafeRange(R, U)
  if (isRandomAccessRange!R &&
      hasSlicing!R          &&
      hasLength!R           &&
      is(U : size_t))
\{
  alias IndexType = U;
  
  R list_;
  alias list_ this;

  auto ref opAssign(R other) \{
    list_ = other;
    return this;
  \}

  @property
  SafeRange save() \{ return this; \}

  auto ref opIndex(in U i) inout \{
    return list_[i];
  \}

  SafeRange opSlice(in U l, in U h)
  \{
    SafeRange other = this;
    other.list_ = list_[l .. h];
    return other;
  \}

  @property
  U opDollar() const \{ return U(length); \}

  private alias T = ElementType!R;
  static if (isAssignable!T) \{
    auto ref opIndexAssign(in T val, in U i) \{
      list_[i] = val;
      return list_[i];
    \}
  \}
\}

struct VanillaIndexed(R)
  if (__traits(isSame, TemplateOf!R, SafeRange))
\{
  R r_;
  alias r_ this;

  this(R r) \{r_ = r;\}

  @property
  VanillaIndexed save() \{ return this; \}

  auto ref opIndex(in size_t i) inout \{
    return r_[R.IndexType(i)];
  \}

  VanillaIndexed opSlice(in size_t l, in size_t h)
  \{
    VanillaIndexed other = this;
    other.r_ = r_[R.IndexType(l) .. R.IndexType(h)];
    return other;
  \}

  private alias T = ElementType!R;
  static if (isAssignable!(T)) \{
    auto ref opIndexAssign(in T val, in size_t i) \{
      r_[R.IndexType(i)] = val;
      return r_[R.IndexType(i)];
    \}
  \}
\}

// For automatic type deduction of R.
auto vanillaIndexed(R)(R r)
\{
  return VanillaIndexed!(R)(r);
\}

\nwendcode{}\nwbegindocs{107}Some convenience functions.

\nwenddocs{}\nwbegincode{108}\moddef{Convenience functions}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
auto ifNull(T : Nullable!U, U)(in T x, in U d)
\{
  return x.isNull ? d : x.get;
\}

auto bound(int val, int min, int max)
\{
  if (val < min) return min;
  else if (val > max) return max;
  return val;
\}

auto lbound(int val, int min)
\{
  if (val < min) return min;
  return val;
\}

auto ubound(int val, int max)
\{
  if (val > max) return max;
  return val;
\}

auto quitIf(bool check, lazy string msg)
\{
  if (check) \{
    stderr.writeln(msg);
    exit(1);
  \}
\}

auto quitOnError(E)(lazy E expr, lazy string msg)
\{
  try \{
    static if (is(E == void)) \{
      expr();
      return;
    \} else \{
      auto result = expr();
      return result;
    \}
  \} catch (Exception e) \{
    stderr.writeln(msg);
    exit(1);
  \}
  assert(0);
\}

auto continueOnError(E)(lazy E expr, lazy string msg)
\{
  try \{
    static if (is(E == void)) \{
      expr();
      return;
    \} else \{
      auto result = expr();
      return result;
    \}
  \} catch (Exception e) \{
    // Ignore exception.
    stderr.writeln(msg);
  \}
\}

auto dstringz(string s)
\{
  auto r = cast(dchar*)malloc(dchar.sizeof * s.length + 1);
  auto x = dtext(s);
  for (auto i = 0; i < x.length; ++i) \{
    r[i] = x[i];
  \}
  r[x.length] = 0;
  return r;
\}

struct Percent
\{
  int value;
\}

auto percent(int val)
\{
  assert(0 <= val && val <= 100,
         "Invalid percentage value.");
  return Percent(val);
\}

\nwendcode{}\nwbegindocs{109}Some useful aliases.

\nwenddocs{}\nwbegincode{110}\moddef{Useful aliases}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
alias FileList.ViewIndex ViewIndex;
alias FileList.FileIndex FileIndex;
alias FileList.GlobIndex GlobIndex;

alias NAME     = FileList.SortField.NAME;
alias MTIME    = FileList.SortField.MTIME;
alias ATIME    = FileList.SortField.ATIME;
alias SIZE     = FileList.SortField.SIZE;
alias GLOB     = FileList.SortField.GLOB;
alias SELECT   = FileList.SortField.SELECT;
alias FILETYPE = FileList.SortField.FILETYPE;

\nwendcode{}\nwbegindocs{111}\section*{Some implementation notes} There are many casts from
unsigned long to int in the program. These do not check for integer
overflow.

Note that we are using {\Tt{}waddwstr\nwendquote} to print file information that
should correctly handle unicode characters in the filename. The
function {\Tt{}dstringz\nwendquote} converts a Dlang {\Tt{}string\nwendquote} into a
null-terminated array of {\Tt{}wchar{\_}t\ =\ dchar\nwendquote} (True in POSIX). The
program also makes the assumption {\Tt{}wchar{\_}t\ =\ wint{\_}t\ =\ dchar\nwendquote} which
is true in POSIX.
\nwenddocs{}
